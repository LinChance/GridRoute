# independent path planning prompt
Vanilla_prompt = (
    "Given these obstacle coordinates in a grid:\n{prompt}\n\n"
    "Please independently plan a continuous path of coordinates from the starting point ({start_x}, {start_y}) "
    "to the ending point ({end_x}, {end_y}), avoiding all obstacles listed above. "
    "The path must follow these rules:\n"
    "1. Every point must differ by exactly 1 in either x or y direction from the previous point (no diagonal moves allowed).\n"
    "2. The output should be in the format: [(x1, y1), (x2, y2), (x3, y3), ...].\n"
    "3. If a valid path cannot be created without touching an obstacle, return an empty path [].\n"
    "Return only the path without any additional explanation."
)

independent_path_CoT = (
    "Here are the obstacle coordinates in the grid:\n{prompt}\n\n"
    "You need to plan a path from the starting point ({start_x}, {start_y}) to the ending point ({end_x}, {end_y}) while avoiding the obstacles. "
    "To ensure accuracy, follow these steps step by step:\n\n"
    "1. Verify that the starting point ({start_x}, {start_y}) and ending point ({end_x}, {end_y}) are not obstacles.\n"
    "2. List all valid moves for a point in the grid. A move is valid if:\n"
    "   - It differs by exactly 1 in either the x or y direction from the previous point.\n"
    "   - It does not overlap with any obstacle.\n"
    "3. Starting from ({start_x}, {start_y}), iteratively choose the next valid move to build a path to ({end_x}, {end_y}).\n"
    "4. If there is no valid path, return an empty path [].\n\n"
    "Return the final path in this format: [(x1, y1), (x2, y2), (x3, y3), ...]. "
    "Make sure to provide only the path in your response without any extra explanations."
)

Few_shot_learning_prompt = (
    "Plan the shortest path from the starting point ({start_x}, {start_y}) to the endpoint ({end_x}, {end_y}) while avoiding rectangular obstacles defined as {prompt}. Follow these steps:\n\n"
    "1. Analyze the grid to identify the start, end, and rectangular obstacle locations.\n"
    "2. Each rectangle is defined by its top-left corner (x1, y1) and bottom-right corner (x2, y2). A grid cell (x, y) is an obstacle if x1 ≤ x ≤ x2 and y1 ≤ y ≤ y2.\n\n"
    "3. Define valid moves:\n"
    " - Right: (x, y+1)\n"
    " - Left: (x, y-1)\n"
    " - Down: (x+1, y)\n"
    " - Up: (x-1, y)\n"
    " - All moves must stay within the grid bounds and avoid obstacle cells.\n\n"
    "4. Build the path:\n"
    " - Start at ({start_x}, {start_y}).\n"
    " - At each step, evaluate valid moves and select the one that minimizes the distance to ({end_x}, {end_y}).\n\n"
    "5. If no valid moves are available, return an empty path [].\n\n"
    "6. Output the result in this format: [(x1, y1), (x2, y2), ..., (xn, yn)].\n\n"
    "Return only the path as output, without additional explanations."
)

# algorithm integration
algorithm_integration_CoT = (
    "Plan the shortest path from the starting point ({start_x}, {start_y}) to the endpoint ({end_x}, {end_y}) while avoiding rectangular obstacles defined as {prompt}. Use Dijkstra's algorithm to calculate the shortest path. Follow these steps:\n\n"
    "1. Analyze the grid to identify the start, end, and rectangular obstacle locations.\n"
    "2. Each rectangle is defined by its top-left corner (x1, y1) and bottom-right corner (x2, y2). A grid cell (x, y) is an obstacle if x1 ≤ x ≤ x2 and y1 ≤ y ≤ y2.\n\n"
    "3. Define valid moves:\n"
    "   - Right: (x, y+1)\n"
    "   - Left: (x, y-1)\n"
    "   - Down: (x+1, y)\n"
    "   - Up: (x-1, y)\n"
    "   - All moves must stay within the grid bounds and avoid obstacle cells.\n\n"
    "4. Use Dijkstra's algorithm:\n"
    "   - Assign an initial distance of infinity to all grid cells except the starting point, which should have a distance of 0.\n"
    "   - Use a priority queue to repeatedly select the grid cell with the smallest tentative distance.\n"
    "   - For each selected cell, evaluate its valid neighbors and update their tentative distances if a shorter path is found.\n"
    "   - Continue until the endpoint ({end_x}, {end_y}) is reached or all possible paths have been explored.\n\n"
    "5. Construct the path:\n"
    "   - Start at ({start_x}, {start_y}).\n"
    "   - Trace back from the endpoint to the starting point using the recorded parent cells to reconstruct the shortest path.\n"
    "   - If no valid moves are available, return an empty path [].\n\n"
    "6. Output the result in this format: [(x1, y1), (x2, y2), ..., (xn, yn)].\n\n"
    "Return only the path as output, without additional explanations."
)

Dijkstra_algorithm_prompt = (
    "Here are the obstacle coordinates in the grid:\n{prompt}\n\n"
    "You need to plan a path from the starting point ({start_x}, {start_y}) to the ending point ({end_x}, {end_y}) while avoiding the obstacles. "
    "Use Dijkstra's algorithm principles to ensure the path is valid and follows the shortest possible route. Follow these steps:\n\n"
    "1. Verify the starting point ({start_x}, {start_y}) and ending point ({end_x}, {end_y}) are not obstacles.\n\n"
    "2. Define the cost of reaching a point in the grid:\n"
    "   - Start by assigning a cost of 0 to the starting point ({start_x}, {start_y}).\n"
    "   - For all other points, initialize the cost as infinity (∞).\n\n"
    "3. Use a priority queue to iteratively explore points in the grid:\n"
    "   - Begin with the starting point ({start_x}, {start_y}) in the queue.\n"
    "   - At each step, select the point with the lowest current cost.\n"
    "   - For each valid move (up, down, left, right):\n"
    "     a. If moving to a neighboring point reduces its cost, update the cost and add the point to the queue.\n"
    "     b. A move is valid if it does not overlap with any obstacle and stays within the grid.\n\n"
    "4. Repeat this process until reaching the ending point ({end_x}, {end_y}) or exhausting all valid points in the queue:\n"
    "   - If the ending point is reached, reconstruct the path by tracing back from the endpoint to the start using the cost values.\n"
    "   - If no valid path exists, return an empty path [].\n\n"
    "5. Return the final path in this format: [(x1, y1), (x2, y2), (x3, y3), ...]. If there are any errors or no valid paths, return [].\n\n"
    "Example:\n"
    "Start: (3, 7), End: (4, 3), Obstacles: [((1, 2), (3, 4)), ((2, 5), (4, 6))], grid: 10 \n\n"
    "Evaluate valid neighbors in the given map.\n"
    "Now, apply the same logic to plan a path from ({start_x}, {start_y}) to ({end_x}, {end_y}) while avoiding the obstacles:\n"
    "Make sure to provide only the path in your response without any extra explanations."
)
